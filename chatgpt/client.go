package chatgpt

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// Client represents the ChatGPT API client
type Client struct {
	apiKey     string
	httpClient *http.Client
	baseURL    string
}

// NewClient creates a new ChatGPT client
func NewClient(apiKey string) *Client {
	return &Client{
		apiKey:     apiKey,
		httpClient: &http.Client{Timeout: 60 * time.Second},
		baseURL:    "https://api.openai.com/v1",
	}
}

// ChatRequest represents a request to the ChatGPT API
type ChatRequest struct {
	Model       string    `json:"model"`
	Messages    []Message `json:"messages"`
	MaxTokens   int       `json:"max_tokens,omitempty"`
	Temperature float64   `json:"temperature,omitempty"`
}

// Message represents a chat message
type Message struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

// ChatResponse represents the response from ChatGPT API
type ChatResponse struct {
	ID      string `json:"id"`
	Object  string `json:"object"`
	Created int64  `json:"created"`
	Model   string `json:"model"`
	Choices []struct {
		Index   int `json:"index"`
		Message struct {
			Role    string `json:"role"`
			Content string `json:"content"`
		} `json:"message"`
		FinishReason string `json:"finish_reason"`
	} `json:"choices"`
	Usage struct {
		PromptTokens     int `json:"prompt_tokens"`
		CompletionTokens int `json:"completion_tokens"`
		TotalTokens      int `json:"total_tokens"`
	} `json:"usage"`
}

// GeneratedQuestion represents a question generated by ChatGPT
type GeneratedQuestion struct {
	Question      string   `json:"question"`
	Type          string   `json:"type"`
	Options       []string `json:"options,omitempty"`
	CorrectAnswer string   `json:"correct_answer"`
	Explanation   string   `json:"explanation"`
}

// GenerateQuestions generates test questions from the provided text
func (c *Client) GenerateQuestions(text string, numQuestions int, questionTypes []string) ([]*GeneratedQuestion, error) {
	if c.apiKey == "" {
		return nil, fmt.Errorf("API key is required")
	}

	prompt := c.buildPrompt(text, numQuestions, questionTypes)

	request := ChatRequest{
		Model: "gpt-3.5-turbo",
		Messages: []Message{
			{
				Role:    "system",
				Content: "You are an expert educator who creates high-quality test questions for PhD students. Always respond with valid JSON format. Ensure your response is complete and not truncated.",
			},
			{
				Role:    "user",
				Content: prompt,
			},
		},
		MaxTokens:   3000,
		Temperature: 0.7,
	}

	response, err := c.makeRequest(request)
	if err != nil {
		return nil, fmt.Errorf("failed to make API request: %w", err)
	}

	if len(response.Choices) == 0 {
		return nil, fmt.Errorf("no response from ChatGPT")
	}

	// Check if the response was truncated
	if response.Choices[0].FinishReason == "length" {
		fmt.Printf("Warning: ChatGPT response was truncated due to length limits\n")
	}

	questions, err := c.parseQuestions(response.Choices[0].Message.Content)
	if err != nil {
		return nil, fmt.Errorf("failed to parse questions: %w", err)
	}

	return questions, nil
}

// buildPrompt creates the prompt for question generation
func (c *Client) buildPrompt(text string, numQuestions int, questionTypes []string) string {
	typesStr := strings.Join(questionTypes, ", ")

	prompt := fmt.Sprintf(`Based on the following text, generate %d test questions. Use these question types: %s.

For multiple choice questions, provide 4 options (A, B, C, D).
For true/false questions, the answer should be "true" or "false".
For short answer questions, provide a concise correct answer.

Always include an explanation for each question.

Respond with a JSON array in this exact format:
[
  {
    "question": "Question text here?",
    "type": "multiple_choice",
    "options": ["Option 1", "Option 2", "Option 3", "Option 4"],
    "correct_answer": "A",
    "explanation": "Explanation here"
  }
]

Text to analyze:
%s`, numQuestions, typesStr, text)

	return prompt
}

// makeRequest makes an HTTP request to the ChatGPT API
func (c *Client) makeRequest(request ChatRequest) (*ChatResponse, error) {
	jsonData, err := json.Marshal(request)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	req, err := http.NewRequest("POST", c.baseURL+"/chat/completions", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+c.apiKey)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make HTTP request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
	}

	var response ChatResponse
	if err := json.Unmarshal(body, &response); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return &response, nil
}

// parseQuestions parses the JSON response from ChatGPT into questions
func (c *Client) parseQuestions(content string) ([]*GeneratedQuestion, error) {
	// Clean the content to extract JSON
	content = strings.TrimSpace(content)

	// Debug: Print the raw content to understand what we're receiving
	fmt.Printf("Raw ChatGPT response:\n%s\n\n", content)

	// Find JSON array in the response
	startIdx := strings.Index(content, "[")
	endIdx := strings.LastIndex(content, "]")

	if startIdx == -1 || endIdx == -1 || startIdx >= endIdx {
		return nil, fmt.Errorf("no valid JSON array found in response. Content: %s", content)
	}

	jsonStr := content[startIdx : endIdx+1]
	fmt.Printf("Extracted JSON:\n%s\n\n", jsonStr)

	// Check if the JSON string is empty or incomplete
	if len(jsonStr) <= 2 {
		return nil, fmt.Errorf("extracted JSON is too short: %s", jsonStr)
	}

	var questions []*GeneratedQuestion
	if err := json.Unmarshal([]byte(jsonStr), &questions); err != nil {
		return nil, fmt.Errorf("failed to parse JSON: %w. JSON content: %s", err, jsonStr)
	}

	// Validate questions
	for i, q := range questions {
		if q.Question == "" {
			return nil, fmt.Errorf("question %d is missing question text", i+1)
		}
		if q.CorrectAnswer == "" {
			return nil, fmt.Errorf("question %d is missing correct answer", i+1)
		}
		if q.Type == "" {
			q.Type = "short_answer" // Default type
		}
	}

	return questions, nil
}

// TestConnection tests the connection to ChatGPT API
func (c *Client) TestConnection() error {
	if c.apiKey == "" {
		return fmt.Errorf("API key is required")
	}

	request := ChatRequest{
		Model: "gpt-3.5-turbo",
		Messages: []Message{
			{
				Role:    "user",
				Content: "Hello, this is a test message. Please respond with 'Connection successful'.",
			},
		},
		MaxTokens: 50,
	}

	_, err := c.makeRequest(request)
	return err
}
